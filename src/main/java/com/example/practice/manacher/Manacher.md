Manacher算法：  
给定一个字符串，返回其最长回文子串的长度。  
更重要的是算法生成的：回文半径数组。  

经典解决方法：以字符串的每一个字符为中心，通过比较其左右两边对应位置的字符是否相同，不断向外扩展，求出以该字符为中心的回文字串及其长度，取最大值返回。  
问题：当原字符串的长度为偶数时，会漏掉一些回文子串。  
比如：1221，最大回文子串1221被漏掉了。  

改进的Manacher算法：在字符串的前后和每个字符之间插入虚拟字符，该虚拟字符不要求与原字符串中的字符不同，按照经典解法计算新字符串的最长回文子串的长度，再除以2（向下取整）即为原字符串最长回文子串的长度。  
比如：#1#2#2#1#， 9/2=4  

概念：  
回文直径：即回文子串的长度；  
回文半径：以某个字符为中心的回文子串，从该中心字符到回文子串左边界或右边界的长度，比如：#2#1#，回文半径 r 为 5；  
回文中心：以某个字符为中心的回文子串，该字符的下标就是回文中心；  
回文左右边界：某个回文子串的起始和结束字符的下标。  

以下讨论都是基于改进算法，但举例为了方便，没有写虚拟字符！！！  
求取回文半径数组（重点）：  
设 i 为当前中心点，C 为上一次的中心点（i 和 C 之间可以有间隔其它的点，后面说），i' 为 i 以 C 为中心的对称点，L 和 R 是中心点为 C 时的回文子串的左右边界：  
o o o o o o o o o o o o o...  
  L     i'  C   i     R  
即：length(LC)==length(CR),length(i'C)==length(Ci).  
且：初始值 C=-1;R=-1，C 和 R 同步变化，回文半径 r=0.  

比如：1221 (#1#2#2#1#)  
初始时：C=-1,R=-1,r=0;
index=0,以#为中心：C=0,R=0,r=1;  
index=1,以1为中心：C=1,R=2,r=2;  
index=2,以#为中心：C=2,R=2,r=1;  
index=3,以2为中心：C=3,R=4,r=2;  
index=4,以#为中心：C=4,R=8,r=5;  
index=5,以2为中心：C=5,R=6,r=2;  
index=6,以#为中心：C=6,R=6,r=1;  
index=7,以1为中心：C=7,R=8,r=2;  
index=8,以#为中心：C=8,R=8,r=1;  
得到回文半径数组：  
[1,2,1,2,5,2,1,2,1]  
最长回文半径：5，（原字符串）最长回文长度 = （带虚拟字符）最大回文半径 - 1.  

如何求取回文半径数组？  
分两种情况：  
1）当前回文中心 i 在上一次回文右边界 R 外，即 i>R，暴力向 i 的左右两边扩；  
2）当前回文中心 i 在上一次回文右边界 R 内，即 i<=R，此时通过 i' 判断；  
①以 i' 为回文中心的回文在 [L,R] 内部，则 i 位置回文半径等于 i' 的回文半径，i' 的回文半径已经求过了，放在回文半径数组里；  
证明：  
o X o o o Y o Y o o o X o o o...  
L     i'    C     i     R  
假设 i' 位置的回文区域为 (X,Y)，不包括 X 和 Y，则必定 X!=Y，否则 i' 位置的回文区域还能向外扩；i 和 i' 是关于 C 对称的，[L,R] 是以 C 为中心的回文子串，所以 i 左右两边的 Y 和 X 也不相等，故 i 的回文半径 = i' 的回文半径。  

②以 i' 为中心的回文区域超出 [L,R]，则 i 位置回文半径就等于 iR 的长度；  
③以 i' 为中心的回文区域左边界刚好等于 L，则 i 位置回文半径最少等于 iR 的长度，能不能继续向外扩，需要进行字符比较（暴力）。  

获取回文半径数组的时间复杂度：O(N)  
分析：  
①回文半径向外扩展，若扩展失败，每个字符（为中心）最多扩展失败 1 次（失败一次即不再向外扩展）；
②若扩展成功，以上述 2 大类 4 种情况分析回文中心 i 变化时回文右边界 R 的变化情况：  
    i       R       Rmax  
1   ↑       ↑     O(N)    
2   ↑     O(1)    O(1)  
3   ↑     O(1)    O(1)  
4   ↑     >=O(1)  O(N)  
所以扩展成功，最大也为 O(N)。  
综上：时间复杂度 O(N).  

